package com.abiodun.expaq.repository;

import com.abiodun.expaq.model.SupportTicketMessage;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Repository
public interface SupportTicketMessageRepository extends JpaRepository<SupportTicketMessage, UUID> {
    
    // Find messages by ticket
    List<SupportTicketMessage> findBySupportTicketIdOrderByCreatedAtAsc(UUID ticketId);
    
    // Find visible messages (non-internal) by ticket
    @Query("SELECT m FROM SupportTicketMessage m WHERE m.supportTicket.id = :ticketId AND m.isInternal = false ORDER BY m.createdAt ASC")
    List<SupportTicketMessage> findVisibleMessagesByTicketId(@Param("ticketId") UUID ticketId);
    
    // Find internal messages by ticket
    @Query("SELECT m FROM SupportTicketMessage m WHERE m.supportTicket.id = :ticketId AND m.isInternal = true ORDER BY m.createdAt ASC")
    List<SupportTicketMessage> findInternalMessagesByTicketId(@Param("ticketId") UUID ticketId);
    
    // Find unread messages by ticket and user type
    @Query("SELECT m FROM SupportTicketMessage m WHERE m.supportTicket.id = :ticketId AND m.readByCustomer = false AND m.sender.id != :userId ORDER BY m.createdAt ASC")
    List<SupportTicketMessage> findUnreadCustomerMessages(@Param("ticketId") UUID ticketId, @Param("userId") UUID userId);
    
    @Query("SELECT m FROM SupportTicketMessage m WHERE m.supportTicket.id = :ticketId AND m.readByAgent = false AND m.sender.id = :customerId ORDER BY m.createdAt ASC")
    List<SupportTicketMessage> findUnreadAgentMessages(@Param("ticketId") UUID ticketId, @Param("customerId") UUID customerId);
    
    // Find latest message by ticket
    @Query("SELECT m FROM SupportTicketMessage m WHERE m.supportTicket.id = :ticketId ORDER BY m.createdAt DESC LIMIT 1")
    SupportTicketMessage findLatestMessageByTicketId(@Param("ticketId") UUID ticketId);
    
    // Find messages by sender
    Page<SupportTicketMessage> findBySenderIdOrderByCreatedAtDesc(UUID senderId, Pageable pageable);
    
    // Find messages by type
    List<SupportTicketMessage> findByMessageTypeOrderByCreatedAtDesc(SupportTicketMessage.MessageType messageType);
    
    // Find auto-generated messages
    @Query("SELECT m FROM SupportTicketMessage m WHERE m.isAutoGenerated = true ORDER BY m.createdAt DESC")
    List<SupportTicketMessage> findAutoGeneratedMessages(Pageable pageable);
    
    // Count unread messages for customer
    @Query("SELECT COUNT(m) FROM SupportTicketMessage m WHERE m.supportTicket.user.id = :customerId AND m.readByCustomer = false AND m.sender.id != :customerId")
    long countUnreadMessagesForCustomer(@Param("customerId") UUID customerId);
    
    // Count unread messages for agent
    @Query("SELECT COUNT(m) FROM SupportTicketMessage m WHERE m.supportTicket.assignedAgent.id = :agentId AND m.readByAgent = false AND m.sender.id != :agentId")
    long countUnreadMessagesForAgent(@Param("agentId") UUID agentId);
    
    // Find messages in date range
    @Query("SELECT m FROM SupportTicketMessage m WHERE m.createdAt >= :startDate AND m.createdAt <= :endDate ORDER BY m.createdAt DESC")
    List<SupportTicketMessage> findByDateRange(@Param("startDate") LocalDateTime startDate, @Param("endDate") LocalDateTime endDate);
    
    // Search messages
    @Query("SELECT m FROM SupportTicketMessage m WHERE LOWER(m.message) LIKE LOWER(CONCAT('%', :searchTerm, '%')) ORDER BY m.createdAt DESC")
    Page<SupportTicketMessage> searchMessages(@Param("searchTerm") String searchTerm, Pageable pageable);
    
    // Message statistics
    @Query("SELECT m.messageType, COUNT(m) FROM SupportTicketMessage m GROUP BY m.messageType")
    List<Object[]> getMessageCountByType();
    
    @Query("SELECT COUNT(m) FROM SupportTicketMessage m WHERE m.isInternal = false")
    long countPublicMessages();
    
    @Query("SELECT COUNT(m) FROM SupportTicketMessage m WHERE m.isInternal = true")
    long countInternalMessages();
    
    // Average response time
    @Query("SELECT AVG(TIMESTAMPDIFF(MINUTE, prev.createdAt, curr.createdAt)) " +
           "FROM SupportTicketMessage curr, SupportTicketMessage prev " +
           "WHERE curr.supportTicket.id = prev.supportTicket.id " +
           "AND curr.createdAt > prev.createdAt " +
           "AND curr.sender.id != prev.sender.id " +
           "AND NOT EXISTS (SELECT 1 FROM SupportTicketMessage mid " +
           "               WHERE mid.supportTicket.id = curr.supportTicket.id " +
           "               AND mid.createdAt > prev.createdAt " +
           "               AND mid.createdAt < curr.createdAt)")
    Double getAverageResponseTimeMinutes();
    
    // Message volume trends
    @Query("SELECT FUNCTION('DATE', m.createdAt) as date, COUNT(m) as count " +
           "FROM SupportTicketMessage m " +
           "WHERE m.createdAt >= :startDate " +
           "GROUP BY FUNCTION('DATE', m.createdAt) " +
           "ORDER BY date DESC")
    List<Object[]> getDailyMessageVolume(@Param("startDate") LocalDateTime startDate);
    
    // Agent activity
    @Query("SELECT m.sender, COUNT(m) as messageCount " +
           "FROM SupportTicketMessage m " +
           "WHERE m.isInternal = false AND m.isAutoGenerated = false " +
           "AND m.createdAt >= :startDate " +
           "GROUP BY m.sender " +
           "ORDER BY messageCount DESC")
    List<Object[]> getAgentActivity(@Param("startDate") LocalDateTime startDate);
    
    // Customer engagement
    @Query("SELECT t.user, COUNT(m) as messageCount " +
           "FROM SupportTicketMessage m " +
           "JOIN m.supportTicket t " +
           "WHERE m.sender.id = t.user.id " +
           "AND m.createdAt >= :startDate " +
           "GROUP BY t.user " +
           "ORDER BY messageCount DESC")
    List<Object[]> getCustomerEngagement(@Param("startDate") LocalDateTime startDate);
}