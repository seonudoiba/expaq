/* eslint-disable @typescript-eslint/no-explicit-any */
import { apiClient } from '@/lib/api/client';

export interface SupportTicket {
  id: string;
  ticketNumber: string;
  subject: string;
  description: string;
  category: 'GENERAL_INQUIRY' | 'BOOKING_ISSUE' | 'PAYMENT_PROBLEM' | 'ACTIVITY_CONCERN' | 
           'ACCOUNT_ISSUE' | 'TECHNICAL_SUPPORT' | 'REFUND_REQUEST' | 'DISPUTE_RESOLUTION' |
           'SAFETY_CONCERN' | 'FEATURE_REQUEST' | 'BUG_REPORT' | 'HOST_SUPPORT' | 
           'COMMISSION_INQUIRY' | 'SUBSCRIPTION_ISSUE' | 'OTHER';
  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'URGENT' | 'CRITICAL';
  status: 'OPEN' | 'IN_PROGRESS' | 'PENDING_CUSTOMER' | 'PENDING_INTERNAL' | 
          'ESCALATED' | 'RESOLVED' | 'CLOSED' | 'CANCELLED';
  customerEmail: string;
  customerName: string;
  assignedAgent?: {
    id: string;
    name: string;
  };
  createdAt: string;
  updatedAt: string;
  dueDate?: string;
  resolvedAt?: string;
  isOverdue: boolean;
  tags: string[];
  customerSatisfactionRating?: number;
}

export interface SupportMessage {
  id: string;
  message: string;
  messageType: 'REPLY' | 'INTERNAL_NOTE' | 'STATUS_UPDATE' | 'AUTO_RESPONSE' | 
               'ESCALATION_NOTE' | 'RESOLUTION_NOTE' | 'CUSTOMER_FEEDBACK';
  isInternal: boolean;
  isAutoGenerated: boolean;
  sender?: {
    id: string;
    name: string;
    isCustomer: boolean;
  };
  createdAt: string;
  readByCustomer: boolean;
  readByAgent: boolean;
}

export interface SupportAnalytics {
  totalTickets: number;
  openTickets: number;
  inProgressTickets: number;
  resolvedTickets: number;
  closedTickets: number;
  categoryDistribution: Record<string, number>;
  priorityDistribution: Record<string, number>;
  averageFirstResponseTimeHours?: number;
  averageResolutionTimeHours?: number;
  averageCustomerSatisfactionRating?: number;
}

export interface SupportQueue {
  unassignedTickets: number;
  overdueTickets: number;
  escalatedTickets: number;
  awaitingFirstResponse: number;
  unassignedDetails: SupportTicket[];
  overdueDetails: SupportTicket[];
}

export const supportService = {
  /**
   * Create a new support ticket
   */
  createTicket: async (ticketData: {
    subject: string;
    description: string;
    category: string;
    priority?: string;
    customerEmail?: string;
    customerName?: string;
    relatedBookingId?: string;
    relatedActivityId?: string;
  }): Promise<{ success: boolean; ticketId?: string; ticketNumber?: string; message: string }> => {
    try {
      const response = await apiClient.post<{ success: boolean; ticketId?: string; ticketNumber?: string; message: string }>('/api/support/tickets', ticketData);
      console.log('Support ticket created:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error creating support ticket:', error);
      return { success: false, message: 'Failed to create support ticket' };
    }
  },

  /**
   * Get ticket by ticket number (public access)
   */
  getTicketByNumber: async (ticketNumber: string): Promise<SupportTicket | null> => {
    try {
      const response = await apiClient.get<SupportTicket>(`/api/support/tickets/${ticketNumber}`);
      console.log('Ticket retrieved:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching ticket:', error);
      return null;
    }
  },

  /**
   * Get current user's support tickets
   */
  getMyTickets: async (page = 0, size = 20): Promise<{ tickets: SupportTicket[]; totalElements: number; totalPages: number; currentPage: number }> => {
    try {
      const response = await apiClient.get<{ tickets: SupportTicket[]; totalElements: number; totalPages: number; currentPage: number }>(`/api/support/my-tickets?page=${page}&size=${size}`);
      console.log('User tickets retrieved:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching user tickets:', error);
      return { tickets: [], totalElements: 0, totalPages: 0, currentPage: 0 };
    }
  },

  /**
   * Add message to ticket
   */
  addMessage: async (ticketId: string, message: string): Promise<{ success: boolean; messageId?: string; message: string }> => {
    try {
      const response = await apiClient.post<{ success: boolean; messageId?: string; message: string }>(`/api/support/tickets/${ticketId}/messages`, {
        message,
      });
      console.log('Message added to ticket:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error adding message to ticket:', error);
      return { success: false, message: 'Failed to add message' };
    }
  },

  /**
   * Get ticket messages
   */
  getTicketMessages: async (ticketId: string): Promise<SupportMessage[]> => {
    try {
      const response = await apiClient.get<SupportMessage[]>(`/api/support/tickets/${ticketId}/messages`);
      console.log('Ticket messages retrieved:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching ticket messages:', error);
      return [];
    }
  },

  /**
   * Set customer satisfaction rating
   */
  setCustomerSatisfaction: async (ticketId: string, rating: number, feedback?: string): Promise<{ success: boolean; message: string }> => {
    try {
      const response = await apiClient.post<{ success: boolean; message: string }>(`/api/support/tickets/${ticketId}/satisfaction`, {
        rating,
        feedback,
      });
      console.log('Customer satisfaction set:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error setting customer satisfaction:', error);
      return { success: false, message: 'Failed to record satisfaction rating' };
    }
  },

  // Admin functions

  /**
   * Get all support tickets (admin only)
   */
  getAllTickets: async (filters: {
    status?: string;
    priority?: string;
    category?: string;
    search?: string;
    page?: number;
    size?: number;
  } = {}): Promise<{ tickets: SupportTicket[]; totalElements: number; totalPages: number; currentPage: number }> => {
    try {
      const params = new URLSearchParams();
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== null && value !== '') {
          params.append(key, value.toString());
        }
      });

      const response = await apiClient.get<{ tickets: SupportTicket[]; totalElements: number; totalPages: number; currentPage: number }>(`/api/support/admin/tickets?${params}`);
      console.log('All tickets retrieved:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching all tickets:', error);
      return { tickets: [], totalElements: 0, totalPages: 0, currentPage: 0 };
    }
  },

  /**
   * Assign ticket to agent (admin only)
   */
  assignTicket: async (ticketId: string, agentId?: string): Promise<{ success: boolean; message: string; assignedAgent?: string }> => {
    try {
      const response = await apiClient.post<{ success: boolean; message: string; assignedAgent?: string }>(`/api/support/admin/tickets/${ticketId}/assign`, {
        agentId: agentId || 'auto',
      });
      console.log('Ticket assigned:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error assigning ticket:', error);
      return { success: false, message: 'Failed to assign ticket' };
    }
  },

  /**
   * Update ticket status (admin only)
   */
  updateTicketStatus: async (ticketId: string, status: string): Promise<{ success: boolean; message: string; newStatus?: string }> => {
    try {
      const response = await apiClient.post<{ success: boolean; message: string; newStatus?: string }>(`/api/support/admin/tickets/${ticketId}/status`, {
        status,
      });
      console.log('Ticket status updated:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error updating ticket status:', error);
      return { success: false, message: 'Failed to update ticket status' };
    }
  },

  /**
   * Escalate ticket (admin only)
   */
  escalateTicket: async (ticketId: string, reason?: string): Promise<{ success: boolean; message: string; escalationReason?: string }> => {
    try {
      const response = await apiClient.post<{ success: boolean; message: string; escalationReason?: string }>(`/api/support/admin/tickets/${ticketId}/escalate`, {
        reason: reason || 'Escalated by support agent',
      });
      console.log('Ticket escalated:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error escalating ticket:', error);
      return { success: false, message: 'Failed to escalate ticket' };
    }
  },

  /**
   * Resolve ticket (admin only)
   */
  resolveTicket: async (ticketId: string, resolutionNotes: string): Promise<{ success: boolean; message: string; resolvedAt?: string }> => {
    try {
      const response = await apiClient.post<{ success: boolean; message: string; resolvedAt?: string }>(`/api/support/admin/tickets/${ticketId}/resolve`, {
        resolutionNotes,
      });
      console.log('Ticket resolved:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error resolving ticket:', error);
      return { success: false, message: 'Failed to resolve ticket' };
    }
  },

  /**
   * Get support analytics (admin only)
   */
  getSupportAnalytics: async (): Promise<SupportAnalytics> => {
    try {
      const response = await apiClient.get<SupportAnalytics>('/api/support/admin/analytics');
      console.log('Support analytics retrieved:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching support analytics:', error);
      return {
        totalTickets: 0,
        openTickets: 0,
        inProgressTickets: 0,
        resolvedTickets: 0,
        closedTickets: 0,
        categoryDistribution: {},
        priorityDistribution: {},
      };
    }
  },

  /**
   * Get agent performance metrics (admin only)
   */
  getAgentPerformance: async (): Promise<any> => {
    try {
      const response = await apiClient.get<any>('/api/support/admin/agent-performance');
      console.log('Agent performance retrieved:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching agent performance:', error);
      return {};
    }
  },

  /**
   * Get SLA compliance metrics (admin only)
   */
  getSLACompliance: async (): Promise<any> => {
    try {
      const response = await apiClient.get<any>('/api/support/admin/sla-compliance');
      console.log('SLA compliance retrieved:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching SLA compliance:', error);
      return {};
    }
  },

  /**
   * Get support queue status (admin only)
   */
  getSupportQueue: async (): Promise<SupportQueue> => {
    try {
      const response = await apiClient.get<SupportQueue>('/api/support/admin/queue');
      console.log('Support queue retrieved:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error fetching support queue:', error);
      return {
        unassignedTickets: 0,
        overdueTickets: 0,
        escalatedTickets: 0,
        awaitingFirstResponse: 0,
        unassignedDetails: [],
        overdueDetails: [],
      };
    }
  },

  /**
   * Add attachment to ticket (admin only)
   */
  addAttachment: async (ticketId: string, file: File, messageId?: string): Promise<{ success: boolean; message: string; filename?: string }> => {
    try {
      const formData = new FormData();
      formData.append('file', file);
      if (messageId) {
        formData.append('messageId', messageId);
      }

      const response = await apiClient.post<{ success: boolean; message: string; filename?: string }>(`/api/support/admin/tickets/${ticketId}/attachment`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      console.log('Attachment added:', response.data);
      return response.data;
    } catch (error) {
      console.error('Error adding attachment:', error);
      return { success: false, message: 'Failed to upload attachment' };
    }
  },

  /**
   * Get ticket categories for forms
   */
  getTicketCategories: () => [
    { value: 'GENERAL_INQUIRY', label: 'General Inquiry' },
    { value: 'BOOKING_ISSUE', label: 'Booking Issue' },
    { value: 'PAYMENT_PROBLEM', label: 'Payment Problem' },
    { value: 'ACTIVITY_CONCERN', label: 'Activity Concern' },
    { value: 'ACCOUNT_ISSUE', label: 'Account Issue' },
    { value: 'TECHNICAL_SUPPORT', label: 'Technical Support' },
    { value: 'REFUND_REQUEST', label: 'Refund Request' },
    { value: 'DISPUTE_RESOLUTION', label: 'Dispute Resolution' },
    { value: 'SAFETY_CONCERN', label: 'Safety Concern' },
    { value: 'FEATURE_REQUEST', label: 'Feature Request' },
    { value: 'BUG_REPORT', label: 'Bug Report' },
    { value: 'HOST_SUPPORT', label: 'Host Support' },
    { value: 'COMMISSION_INQUIRY', label: 'Commission Inquiry' },
    { value: 'SUBSCRIPTION_ISSUE', label: 'Subscription Issue' },
    { value: 'OTHER', label: 'Other' },
  ],

  /**
   * Get ticket priorities for forms
   */
  getTicketPriorities: () => [
    { value: 'LOW', label: 'Low' },
    { value: 'MEDIUM', label: 'Medium' },
    { value: 'HIGH', label: 'High' },
    { value: 'URGENT', label: 'Urgent' },
    { value: 'CRITICAL', label: 'Critical' },
  ],

  /**
   * Get ticket statuses for filters
   */
  getTicketStatuses: () => [
    { value: 'OPEN', label: 'Open' },
    { value: 'IN_PROGRESS', label: 'In Progress' },
    { value: 'PENDING_CUSTOMER', label: 'Pending Customer' },
    { value: 'PENDING_INTERNAL', label: 'Pending Internal' },
    { value: 'ESCALATED', label: 'Escalated' },
    { value: 'RESOLVED', label: 'Resolved' },
    { value: 'CLOSED', label: 'Closed' },
    { value: 'CANCELLED', label: 'Cancelled' },
  ],
};

export default supportService;